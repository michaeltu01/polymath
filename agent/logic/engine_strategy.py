# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.

from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, Tuple

from libcst import MetadataWrapper, Module


class SolverOutcome(Enum):
    """
    Result codes for solver invocations.
    """

    # Solver invocation was successful and we have a result to report.
    SUCCESS = 1

    # Solver invocation failed, and the constraints should be generated from
    # scratch if the model wants to retry. We classify e.g. syntax errors in
    # this category, from which it is difficult for the model to recover.
    FATAL = 2

    # Solver invoation failed. If the model wants to retry, it can try to amend
    # the existing constraint. As an example, if CBMC returns UNSAT because the
    # search constraints were contradictory, we tell the model to review them
    # using this response.
    RETRY = 3


class EngineStrategy(ABC):
    """
    Implementations of this interface are solver interaction strategies for the
    different constraint solver back-ends and tasks supported by Logic.py.
    Implementations may choose to send different prompts and invoke different
    constraint solvers from each other.
    """

    @property
    @abstractmethod
    def constraints_prompt(self) -> list[str]:
        """
        Prompt sent to the LLM instructing it to generate the constraints over a
        previously defined data structure or universe that it thinks will answer
        the problem. Implementations are free to generate as many messages for
        the LLM, the agent assumes these messages correspond to independent code
        snippets to be generated.
        """
        ...

    @property
    @abstractmethod
    def data_structure_prompt(self) -> str:
        """
        Prompt sent to the LLM instructing it to generate the basic data
        structure over which it would like to express constraints.
        """
        ...

    @abstractmethod
    async def generate_solver_constraints(
        self, module: Module, metadata: Optional[MetadataWrapper]
    ) -> str:
        """
        All supported solvers are invoked using a CLI interface (e.g. `cbmc`,
        `z3`). This method generates constraints for the implemented solver
        back-end, which are written into a temporary file, then passed into the
        solver in a subsequent step.

        Args:
            module (Module): Logic.py Python module to translate.
        Returns:
            Solver-specific constraints to later pass into solver engine.
        """
        ...

    @abstractmethod
    def generate_solver_invocation_command(self, solver_input_file: str) -> list[str]:
        """
        Generates the CLI command to invoke the solver back-end.

        Args:
            solver_input_file (str): Path to file with content generated by
            `generate_solver_constraints(...)`, i.e. a temporary file containing
            the solver-specific input constraints.
        Returns:
            CLI command to invoke constraint solver subprocess.
        """
        ...

    @abstractmethod
    def get_format_prompt(self, solution: str) -> Optional[str]:
        """
        Prompt sent to the LLM instructing it to format the given
        solver-formatted solution to the actual output format expected by the
        user.

        Args:
            solution (str): Solution in solver format.
        Returns:
            Formatting prompt to send to LLM.
        """
        ...

    @abstractmethod
    def parse_solver_output(
        self, exit_code: int, stdout: str, stderr: str
    ) -> Tuple[SolverOutcome, Optional[str]]:
        """
        Interprets the result of the constraint solver subprocess invocation.

        Args:
            exit_code (int): Constraint solver subprocess exit code.
            stdout (str): Standard output of constraint solver subprocess.
            stderr (str): Standard error output of constraint solver subprocess.
        Returns:
            A tuple where the first element indicates the outcome (i.e. whether
            we succeeded or should retry), and optionally the solution in solver
            format if the invocation was succesful.
        """
        ...

    @property
    @abstractmethod
    def python_code_prefix(self) -> str:
        """
        Code to prefix in front of code generated by the model. This is intended
        to allow defining helper functions or constants - or placeholders for
        these for type checking.
        """
        ...

    @property
    @abstractmethod
    def retry_prompt(self) -> str:
        """
        Message to send to the LLM if it should try to fix the constraints, i.e.
        when we return `SolverOutcome.RETRY`.
        """
        ...

    @property
    @abstractmethod
    def solver_input_file_suffix(self) -> str:
        """
        File suffix for the solver's constraints file, e.g. `.c` for CBMC and
        `.smt` for Z3.
        """
        ...

    @property
    @abstractmethod
    def system_prompt(self) -> str:
        """
        Initial system prompt for the model. Usually, this already contains most
        the instructions for the first step, i.e. the data structure generation.
        """
        ...
